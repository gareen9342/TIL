# 수학1   
   
## 나머지 연산

컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 때문에, 답을 M으로  나눈 나머지를 출력하라는 문제가 등장한다. 

```java
 (A+B)modM=((AmodM)+(BmodM))modM
 (A×B)modM=((AmodM)×(BmodM))modM
```

나누기의 경우에는 성립하지 않는다. 

뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 해야 한다. 

```java
    (A-B)modM=((AmodM)‒(BmodM)+M)modM
```

문제에서 정답을 ~로 나눈 나머지를 출력하라 라고 한다면 **정답이 int나 long과 같은 자료형의 범위를 넘어가기 때문이다.** 

매번 나눠주면 된다. 

## 최대공약수

최대공약수는 줄여서 gcd라고 한다. 

두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다. 

최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A, B)까지 모든 정수로 나누어 보는 방법

→ 하지만 효율성이 정말 많이 떨어진다. 

```java
int g = 1;
for (int i=2; i<=min(a,b); i++) {
    if (a % i == 0 && b % i == 0) {
        g = i;
} }
```

제일 좋은 방법은 유클리드 호제법 을 이용하는 방법이다. 

a를 b로 나눈 나머지를 r이라고 했을 때

gcd (a, b) = gcd (b, r);

r이 0이면 그 때 b가 최대공약수이다.

 **GCD(24,16)=GCD(16,8)=GCD(8,0)=8**

- 재귀함수를 사용해서 구현한 유클리드 호제법

```java
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a%b);
    }
}
```

- 재귀함수 x

```java
int gcd(int a, int b) {
    while (b != 0) {
        int r = a%b;
				a = b;
				b = r; 
		}
		return a; 
}
```

## 최소공배수

최소공배수는 줄여서 LCM 이라고 한다.

두수 a,b의 최대공약수를 g라고 했을때

 최소공배수 = g * (a/g) * ( b/g) 이 다.

## 소수

소수 : 약수가 1과 자기 자신 밖에 없는 수 

N 이 소수가 되려면, 2보다 크거나 같고, N-1 보다 작거나 같은 자연수로 나누어 떨어지면 안된다. 

소수와 관련된 알고리즘은 2가지가 있다.

1. 어떤 수 n이 소수인지 아닌지 판별하는 방법
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

1번

```java
bool prime(int n) {
    if (n < 2) {
        return false;
    }
    for (int i=2; i<=n-1; i++) {
        if (n % i == 0) {
            return false;
        }
}
    return true;
}
```

2번

2보다 크거나 같고, 루트 n보다 작거나 같은 자연수로 나누어 떨어지면 안된다.

이유 : n이 소수가 아니라면, n= a*b 로 나타낼 수 있다. 

```java
bool prime(int n) {
    if (n < 2) {
        return false;
    }
    for (int i=2; i*i<=n; i++) {
        if (n % i == 0) {
            return false;
        }
		}
    return true;
}
```

어떤 수  n 이 소수인지 아닌지 알아내는데 걸리는 시간 복잡도는 O(루트N) 이었다.

하지만 범위가 10억쯤 된다면 너무 많은 시간이 걸린다. 

1부터 n까지 범위 안에 들어가는 모든 소수를 구하려면 에라코스테네스의 체를 사용한다. 

1. 2부터 N까지 모든 수를 써놓는다. 
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다 
3. 그 수는 소수이다.
4. 이제 그 수의 배수를 모두 지운다. 

```java
int prime[100]; // 소수 저장
int pn=0; // 소수의 개수
bool check[101]; // 지워졌으면 true int n = 100; // 100까지 소수
for (int i=2; i<=n; i++) {
    if (check[i] == false) {
        prime[pn++] = i;
        for (int j = i*i; j<=n; j+=i) {
            check[j] = true;
} }
}
```

1부터 n까지 모든 소수를 구하는 것이 목표이기 때문에, 구현할 때는 바깥 for문 i를 N까지 돌린다.

안쪽 for문 (j)는 n의 크기에 따라서 ,  i * i또는 i * 2로 바꾸는 것이 좋다. 

( i 가 백만일경우  i * i는 범위를 넘어가기 때문이다. )

## 팩토리얼

- 팩토리얼은 매우 큰 값

## 팩토리얼의 0의 개수

N!의 0이 몇 개 인지 알아내려면 N!을 소인수분해 했을 때, **2와 5가 몇 개 나오는지 알아야 한다.** 

**5의 개수가 항상 2의 개수 보다 적기 때문에, 5의 개수만 세어주면 된다.** 

```java
N!0의개수= ⌊N/5⌋+⌊N/52⌋+⌊N/53⌋+...
```

## 조합 0의 개수

nCm의 0의 개수를 구하는 문제

팩토리얼은 2의 개수가 5의 개수 보다 항상 많기 때문에, 5의 개수만 세어줬는데 

조합은 어떻게 될 지 모르기 때문에, 2의 개수와 5의 개수를 동시에 세어줘야 한다.