# BFS 
> 모든 가중치가 1일 때, 최단 거리를 구하는 알고리즘   

**BFS를 이용해 해결할 수 있는 문제는 아래와 같은 조건을 만족해야 한다.**    

1. 최소 비용 문제여야 한다. (최단거리)   
2. 간선의 가중치가 1이어야 한다. : 문제에서 요구하는 최솟값 ( 거리, 시간..)   
3. 정점과 간선의 개수가 적어야 한다. ( 적다는 것은 문제의 조건에 맞춰서 해결할 수 있다는 것을 의미한다. )   

## 숨바꼭질

**수빈이의 위치 : N**   
**동생의 위치 : K**   

동생을 찾는 **가장 빠른 시간**을 구하는 문제   

수빈이가 할 수 있는 행동은 위치가 X 에 있을 때 , X+1 혹은 X-1로 1초만에 이동, 혹은 순간이동으로 2*x 로 이동하는 방법이 있다.    

BFS로 푼다는 것은 문제를 그래프로 바꾸어 생각한다는 것을 의미. 그럼 무엇이 정점이며 무엇이 간선일까?   
v◊
정점: 수빈이의 위치, 간선 : 위치와 위치의 관계   


방문했는지, 안했는 지에 대한 상태를 기록할 check 라는 배열을 만들어 준다.    

check[i] = i를 방문했는 지   
dist[i] = i를 몇 번 만에 방문했는 지    

```cpp
int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    push(n); // queue에다가 n을 넣음
    check[n] = 1;
    dist[n] = 0;
    while (begin < end) {
        int now = pop();
        int temp[3] = {now - 1, now + 1, now * 2 }; // 현재 있는 위치로 부터 가능한 3가지 옵션들
        for (int k = 0; k < 3; k++) {
            int next = temp[k]; // 다음에 어디로 갈 것인지 세팅하기.
            if (0 <= next && next <= MAX) {
                if (check[next]) continue; // 이미 갔던 곳일 경우 다음 인덱스로 
                push(next); // 
                check[next] = 1;
                dist[next] = dist[now] + 1; // 거리를 표시해 줄 배열에..
            }
        }
    }
    printf("%d\n", dist[m]);
    return 0;
}
```

## 숨바꼭질4

위의 문제와 같음...   

**근데 이동하는 방법을 구해야하는 것이다. from이란 배열에 바로 전에 방문했던 곳을 저장해줘야 한다**    

fron[i] : 어디에서 왔는지    

N에서 K를 가는 문제이기 때문에   

K부터 From 을 통해서 N까지 가야한다.    

***역순으로 저장되기 때문에, 다시 역순으로 구해줌***   

**→ 이것을 역추적이라고 한다.**    

역추적 방법 1 :  from의 이전 값을 계속 찾아주며 프린트   

```cpp
void print(int n, int m) {
	if (n != m) {
		print(n, from[m]);
	}
	cout << m << ' ';
}
```

역추적 방법 2:    

역추적 방법중 가장 멋진 방법은 스택을 활용하는 것이다.    

```cpp
stack<int> ans;
for (int i=m;i!=n;i=from[i]) { // n까지 발견하게 되면 모두 추적한 것이기 때문에 이렇게 해줌 
	ans.push(i);
}
	ans.push(n);
while (!ans.empty()) {
	cout << ans.top() << ' ';
	ans.pop();
}
cout <<'\n';
```

## 알고스팟

미로는 N*M크기이고, 총  1*1크기의 방으로 이루어져 있다.       
빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.   

(x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x-1, y) (x, y+1), (x, y-1) 이다.   

(1, 1)에서 (n,m)으로 이동하려면 벽을 최소 몇 개 부수어야 하는 지 구하는 문제   

→ 벽은 0개 부쉇을때 갈 수 있는 정점, 1개 부쉈을 때, 2개 부쉈을 때.. n개,..   

일단 거리를 기록할 배열은 전체적으로 -1로 세팅 후에 (x,y)기준으로 상하좌우를 검사해주고,    

벽이 없을 경우 (0) 있을 경우 (1) 을 나누어서   

벽이 없는 경우는 거리를 기록하는 배열에 이전 값 그대로 기입, 아닐 경우는 +1값을 넣어준다.   

```cpp
for (int k=0; k<4; k++) {
      int nx = x+dx[k];
      int ny = y+dy[k];
      if (0 <= nx && nx < n && 0 <= ny && ny < m) {
           if (d[nx][ny] == -1) {
              if (a[nx][ny] == 0) {
                   d[nx][ny] = d[x][y];
                   q.push(make_pair(nx,ny));
              } else {
                   d[nx][ny] = d[x][y]+1;
                   next_queue.push(make_pair(nx,ny));
              }
         }
    }
}
```