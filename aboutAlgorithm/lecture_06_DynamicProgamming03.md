## 카드 구매하기

구매할 카드의 개수 N개가 있고, 카드의 가격이 들어있는 배열 P가 있다고 했을 때
나올수 있는 최대 구매 금액을 구하라.

가장 마지막에 구매한 카드의 개수를 i라고 쳤을 때 
나머지의 개수는 N - i 개 남았다고 할 수 있다. 
이를 가지고 점화식을 작성하게 되면

**D[N] = max(D[N-i] + P[i])** 

가 될 수 있다 . ( 이때 i 는 1 ≤ i ≤ N )

```java
for (int i = 0; i < n; i++){
	for( int j = 1; j <= i; j++}{
		d[i] = max(d[i] , d[i-j] + p[j]);	
	}
}
```

최소값을 구하는 경우에는 무조건 0으로 초기화를 하면 안된다. 
아예 최대값으로 세팅을 하던가. -1로 세팅을 하던가. 두 가지 방법이 있다.

```java
for (int i = 1; i <= n; i++)
	d[i] = -1;

d[0]= 0;
//초기 배열 세팅 끝

for(int i = 1; i<=n; i++){
	for(int j = 1; j <= i ; j++){
		if(d[i] == -1 || d[i] > d[i-j] + a[j]){
			d[i] = d[i-j] + a[j];
		}
	}
}
```

## 1,2,3 더하기 5

어떤 수를 1,2,3 만 써서 만들 수 있는 모든 경우의 수의 개수를 구하는 것.
단, 이 전에 있던 값이랑 중복된 수를 연속으로 써선 안된다. 

**D[i][j]= i  를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용할 수 는  j**

1로 시작하게 될 경우 → D[i][1] = D[i-1][2] + D[i-1][3]

....

최종적으로는 다 더해주고 끝. 

## 쉬운 계단 수

인접한 자리의 차이가 1이 나는 수를 계단 수라고 한다. 
예 : 45656
길이가 N인 계단 수의 개수를 구하는 문제
길이가 N인 수의 마지막 번째 자리가 L 이라고 치면, 
N-1번째 자리의 수는 L - 1 혹은 L + 1이 될 것이다. 
또한 L 이 0인 경우나. L 이 9인 경우를 예외로 처리를 해주며 진행해나가면 된다. 

## 이친수

다음의 조건을 만족하는 수를 구하면 이친수이다. 

1. 이친수는 0으로 시작하지 않는다. 
2. 이친수는 1이 두 전 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다. 

N자리 이친수의 개수를 구하는 문제.


이것은 1차원 다이나믹과 2차원 다이나믹으로 푸는 방법이 있는데

2차원 다이나믹의 경우는 

일단 D[0] = 1이다. D[1] = 1 이다. 
이 값을 세팅해 놓고 진행하며 
전체적인 값을 구함.


1차원 다이나믹으로 풀면 이러하다
D[N] 에 대해서,
마지막 수가 0인 첫 번째 방법과 마지막수가 1인 두 번째 방법이 있다고 생각해보자.


1. 마지막 수가 0인 이친수
 → N - 1 자리는 0 혹은 1

2. 마지막 수가 1인 이친수라면,
→ N-1 자리는 무조건 0 
→ 이 경우는 N자리와 N - 1자리를 묶어서 생각할 수 있다.  
→ 이 경우는 D[N-2]

차원이라는 것은 문제에서 구해야하는 답의 변수라고 생각하면 된다.
차원이 높다고 해서 더 어렵게 풀게 되는 것은 아니다. 
문제에 나와있는 것을 그대로 풀면 안되고, 문제에서 나와있는 조건을 충족시키기 위해 추가적인 조건을 달아야 한다.
그 과정에 대한 고민을 심도있게 해 볼 필요가 있다. 