# Dynamic Programming   

_큰 문제를 작은 문제로 쪼개서 푸는 알고리즘_   
작은 문제를 풀고 → 큰 문제를 푼다는 뜻.   


이렇듯 문제의 단위를 쪼개서 푸는 것은 크게 두 종류가 있다.

1. DP : 중복이 있을 수 있다.
2. 분할 정복 (DI)  : 중복이 있어선 안된다. 

다이나믹 프로그래밍은 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다. 

1. Overlapping Subproblem : 겹치는 부분 문제
2. Optimal Substructure : 최적 부분 구조  (문제의 정답이 작은 부분의 문제를 통해 구할 수 있다.)

Overlapping problem의 대표적 예시

- 피보나치 수
- 문제 : N번째 피보나치 수를 구하는 문제
- 작은 문제 : N - 1번째 피보나치수를 구하는 문제, N - 3 번째 피보나치 수를 구하는 문제,

일반적으로 피보나치 수열의 재귀적 풀이는 메모리를 많이 잡아먹는다. 
왜냐하면 함수의 호출이 많이 겹치기 때문이다.
예를 들어서 f(5)가 있다고 생각해보자. 

f(5) = f (4) + f(3)이다. 
f(4) = f(3) + f(2)이다. 

이렇듯 겹치는 호출의 결과를 메모해서 활용하면 불필요한 함수의 호출을 줄이며 효율적인 프로그래밍을 할 수 있다. (메모이제이션)

```java
int memo [100];
int fibonacci(int n){
	if(n<=1){
		return n;
	}else{
		if(memo[n] > 0){
			return memo[n]; --->>중복이 되는 결과 값이 있다면 그 값을 사용한다. 
		}

		memo[n] = fibonacci(n-1) + fibonacci(n-2);
		return memo[n];
	}

}
```

다이나믹의 구현 방식에는 두 가지 방법이 있다. 

1. **Top-down**
2. **Bottom-up**

보통 Top-down 같은 경우는 재귀를 사용하고, Bottom-up 같은 경우는 반복문을 사용한다. 
두 가지는 시간차이는 알 수 없다. 일단 두 가지를 섭렵한 뒤 자신있는 방식을 선택해서 푸는 것이 가장 좋다.