# 비트 연산

정수(Integer)의 최대 범위 (자바 기준) 는   
4 bytes = 32 bits (32칸의 이진수가 들어갈 수 있는 칸이 생김)    
32칸으로 표현할 수 있는 숫자의 가짓수는 2^32 이다.   
최대 숫자의 크기는 2 ^ 32 - 1 (0부터 시작하므로)   

하지만 정수의 종류에는 양의 정수와 음의 정수가 있다.   
그래서 칸의 맨 앞에는 + - 사인을 써줘야 한다. 따라서 범위는 총  
**-2^31 ~ 2^31 - 1**
이 이상을 알아내려면 더 큰 데이터 타입을 써줘야 한다.   

## 연산식들
    0011 | 0101 -> 0111   
    0011 & 0101 -> 0001   
        ~0101 -> 1010 (NOT연산 , 반대로 바꿔줌)   
    1101 ^ 0101 -> 1000(XOR연산 , 다른 값을 가지고 있을 경우 1로 세팅)   
    1001 << 2 -> (Shift연산, 기호의 방향으로 밀고 빈 곳은 0세팅 혹은 자름)   

## 어떤 규칙들이 있을까   

XOR은 어떤 값이든 0과 연산을 하면 자기 자신이 나온다 어떤 값을 1로 연산하면 반대값 (낫) 으로 나온다.
AND은 어떤 값을 모두 0 으로 세팅된 값으로 계산을 하게 되면 0이 나온다. 
    또 어떤 값은 모두 1로 세팅된 값으로 계산을 하게 되면 원본 값이 나온다.
    자기자신과 연산하면 자기 자신이 나온다
OR 연산은 자기 자신을 모두 0으로 세팅 값으로 연산을 하게 되면 결과는 원래 그 값을 고스란히 가지게 된다.

## 확장해서 생각해보자


### get bit
 9라는 숫자가 주어졌다 그리고 3번 인덱스의 값이 무엇인지 알아보고 싶다.   
 그리고 그 값을 원본 값과 & 연산을 하게 된다면 9의 3번째 인덱스의 값이 어떤 값인지 알 수 있다.   
```java
  
    int num = 9; // 1001
    int i = 3; // 11
    1000 = 1<<3 // 1을 왼쪽으로 3만큼 옮김
    
    static boolean getBit (int num, int i){
        return (num & (1<<i)) != 0;
    }
    
```

### set bit
주어진 5라는 수를 이진법으로 변환했을 시에 i번째 인덱스의 값을 1로 세팅했을 때의 값을 구해보자.

```java
  
    static int setBit(int num, int i){
        return num | (1 << i);
    }

```

### clear bit
해당 자리수를 무조건 0으로 세팅하는 함수
```java
    
    어떠한 수가 있으면 자리수의 인덱스를  0으로 세팅하고 나머지를 1로 세팅하여 만든뒤
    & 연산자를 이용하여 계산해주면 된다
       XXXX   
     & 0111 ->  그럼 이건 어떻게 만들까?   

    -------------- 만드는 법 --------------
    0111 -> ~1000

     static int clearBit(int num, int i){
        return num & ~(1<<i);
    }
```


### clearLeftBit

해당 인덱스를 시작으로 왼쪽의 비트들을 모두 0으로 세팅하고 싶다. 
  xxxxxxx   
& 0000111   
  0000xxx   

```java
int num = 169;
int i = 3;

먼저 인덱스만큼 left shift 
1000 = 1 << 3   
0111 = 1000 - 1   (여기서 NOT연산을 하지 않는 이유는 그냥 NOT 을 하게 되면 원하지 않는 뒤의 자리수 들도 1로 변환함...)

static int clearRightBits (int num, int i){
    // -1 (모든 비트를 1로 세팅) << ( i + 1 ) 원하는 인덱스를 포함하니 +1해서 &연산으로 0으로 세팅
    return num & (-1 << (i + 1))
}

```   