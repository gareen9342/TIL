## 스케줄링 알고리즘

평균 대기시간 : 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값    
평균 반환시간 : 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값

### FCFS (First-Come First-Served)

**비선점** / **도착순서에 따라 디스패치** 된다.

겉보기에는 공정해 보일 수 있는데, 짧은 작업이 긴 작업을 기다리게 될 수도 있고 , 중요한 프로세스가 나중에 수행될 수도 있어서 대화식 시스템에는 적합하지 않다. 

우선순위가 모두 같을 때에 사용하면 좋은 기법

### SJF (Shorted Job First)

**비선점** / 준비큐에서 기다리는 프로세스 중 **실행시간이 가장 짧다고 예상된 것을 먼저** 디스패치

**일괄처리 환경**에서 구현하기 쉬운 알고리즘  

실행 예정 시간의 길이를 사용자의 추정치에 의존하기 때문에, 실제로는 먼저 처리할 작업의 CPU 시간을 예상할 수 없다. 

대화형 시스템에선 사용하지 않음

### SRT (Shortest Remaining Time)

**SJF의 선점방식이다** 

새로 들어오는 프로세스를 포함하여, 실행이 끝날 떄까지 남은 시간 추정치가 가장 짧은 프로세스를 먼저 디스패치 한다. 

SRT가 SJF 보다 평균 반환ㅅ ㅣ간에서 효율적이다. 하지만, 실행되는 작업의 실행시간을 매번추적하고, 문맥 교환 등의 비용을 생각하면,
오버헤드가 크다. 

(문맥교환은 모든 선점 알고리즘에서 사용된다. )

어떤 작업이 선점되게 되면, PCB(프로세스 제어 블록 )에 처리정보가 저장되어야 하며, 이의 내요이 적정ㄹ한 헤지스터로 적재되는 이 과정이 문맥교환

빠르지만, 이런 장점이 문맥교환하는 시간으로 사라질 수 있다. 

그래서, 문맥교환이 요구하는 시간을 고려하여 효율성을 평가.

만약 실행 중인 작업이 거의 끝날 무렴 실행시간의 추정치가 매우 작은 작업이 새로 입력되었다고 가정한다면, 선점 되는 것이 과연 바람직한 것인지 의문을 가지게 될 것 

이런 문제를 해결하기 위하여 임계치를 설정 -> 실행 중인 작업이 완료되기까지 남은 시간이 정해진 임계치보다 작다면, 시스템은 그것을 계속 수행

### RR (Round Robin)

대화형 시스템에서 사용되는, 선점

프로세스가 도착한 순서대로 프로세스를 디스패치하지만, 정해진 시간의 할당량을 모든 프로세스에게 주고, 할당된 시간 안에 완료되지 못한 프로세스는 준비 큐의 맨 뒤에 배치되도록 하여
CPU를 독점하지 않고 공평하게 이용될 수 있게 한다. 

이 알고리즘의 성능은 평균 CPU 소요기나에 대한 시간간격의 길이에 따라 달라진다. 

-> 시스템 형태에 따라 적절한 시간 간격을 정해줄 수 있다. 

대화형 - 빠르게 응답이 중요
일괄처리  - 오버헤드 안 생기게 하는 것이 중요

일반적인 규칙 두 가지 - 80 % CPU 사이클을 처리할 수 있도록 하는 것, 한 번의 문맥교환에 걸리는 시간보다 100배 정도는 길어야 한다. 


### HRN (Highest Response Ratio Next)

비선점 / 준비 큐에서 기다리는 프로세스 중 응답비율((대기시간 _ 예상 실행시간 ) / 예상 실행시간) 이 가장 큰 것을 먼저 디스패치

SJF 스케줄링의 단점을 보완한 것 

### 다단계 피드백 큐 스케줄링 

선점 / 입출력 중심인 프로세스와 CPU 중심인 프로세스의 특성에 따라 서로 다른 시간 할당량을 부여한다. 

각 단계의 큐마다 주어진 시간 할당량을 모두 소비하고, 선점된 프로세스는 큰 단계 큐로 ㄷ가고, 그렇지 않은 프로세스는 점차 작은 단계로 갈 수 있게 하는 적응적 방식의 변형도 있다.





