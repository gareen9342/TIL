
# 도커 이미지를 만들어 보기

## 도커 이미지 생성하는 순서

1. 도커 파일 작성
2. 도커 클라이언트에 전달
3. 도커 서버로 전달해 중요한 적업
4. 이미지 생성


## 도커 파일을 만드는 순서

1. 베이스 이미지를 명시 - *OS와 같은 것* (파일 스냅샷)
2. 추가적으로 필요한 파일을 다운 받기 위한 몇 가지 명령어를 명시해줌
3. 컨테이너 시작시 실행할 명령어 명시해줌

```dockerfile
# 베이스 이미지 명시
#FROM baseImage
FROM alpine

# 추가적으로 필요한 파일을 명시해준다.
#RUN command

# 컨테이너 시작시 실행 될 명령어를 명시해준다.
#CMD ["executable"]

CMD ["echo", "hello"]


```

### FROM

이미지 생성시 기반이 되는 이미지 레이어

<이미지 이름>: <태그> 형식으로 작성한다.

태그를 안 붙이면 자동적으로 가장 최신것으로 다운받음

`ex)ubuntu:14.04`

### RUN

도커이미지가 생성되기 전에 수행할 쉘 명령어

### CMD

컨테이너가 시작되었을 떄 실행할 실행 파일 또는 쉘 스크립트

해당 명령어는 DockerFile내 1회만 쓸 수 있음


## 순서

1. 도커 파일을 만들 폴더 하나 만듬
2. 도커 파일 폴더 내에 Dockerfile이란 파일 하나 생ㅇ성
3. 어떻게 진행해 나갈지 기본적인 토대를 명시함
4. 베이스 이미지부터 실제 값으로 추가해줌
5. 베이스 이미지는 우분투든 센트오에스등 써도 되지만 hello를 출력하는 기능은
   굳이 큰 베이스 이미지를 쓸 필요가 없어서 사이즈가 작은 alpine베이스 이미지를 사용할 수 있다.

이렇게 파일을 만들어 두고 나면 도커 파일에 입력된 것들이 도커 클라이언트에 전달되어서 도커 서버가 인식하게 해야 한다.

`docker  build ./` 또는 `docker build .`

생성된 도커 이미지를 확인한 후에 docker run -it <image name> 해보자

## 도커 이미지에 이름 주기

`docker build -t <my docker id>/<repository/project name>:<version>`

ex

`docker build -t kklily592/hello:latest ./`

`docker run -it kklily592/hello`****



## 파일 작성

COPY ./ ./으로 전체적으로 디렉토리 하위에 있는 것을 복사한다
그리고 빌드하고 실행할 때 컨테이너에서 돌아가는 포트가 실제 브라우저에서 실행될 수 있는 포트랑은 다를 수 있다

이걸 매핑해줘야 하는데 -p 4000:8080

WORKDIR : 이미지안에서 어플리케이션 소스 코드를 가지고 있을 디레토리를 생성하는 것
이 디레고리가 어플리케이션에 working directory가 된다.

따로 working directory가 있어야하는 이유: node 이미지속의 root 디렉토리에는 다양한 파일들이 있다.

만약에 어플리케이션 코드 내부에 home 디렉토리가 있을 경우에 원래있던 디렉토리를 삭제하고 어플리케이션 내의 홈디렉토리로 대체하게 되낟.
이런 부분에 있어서 워킹디렉토리를 따로 설정해주어야할 필요성이 있다.

WORKDIR 설정으로 이미지내부에 특정 디렉토리를 지정해 빌드파일을 넣을 부분을 지정할 수 있다


## 볼륨

도커 볼륨을 이용한다는 건,   
로컬에 있는 것을 계속 복사를 한다는 것이 아니라    
로컬에 있는 파일을 도커 컨테이너에서 계속해서 참조하게 된다는 것   
해당 명령은 docker run -d -p 5000:8080 -v /usr/src/app/node_modules -v $(pwd)/usr/src/app <image >
이름 등으로 이용