# 브루트 포스 (BruteForce) 

Brute Force ? **모든 경우의 수를 다 해보는 것** 

모든 상황을 하나씩 다 실행해보는 것 

## 브루트 포스로 문제를 풀기 위한 세 가지 단계

1. 문제의 가능한 경우의 수를 계산해본다. 
직접 계산을 통해 한다. 손으로 계산   
2. 가능한 모든 방법을 다 만들어 본다.    
하나도 빠짐 없이 다 만들어야 한다   
대표적으로 그냥 다 해보는 방법, for문 사용, 순열, 재귀호출, 비트마스크 사용이 있다.    
3. 각각의 방법을 이용해 답을 구해본다.   

## 경우의 수

- N명의 사람이 한 줄로 서는 경우의 수 : N!
- N명의 사람 중에서 대표 두 명을 뽑는 경우의 수  → $NC2 = (N * (N-1)) / 2$!
- N명의 사람 중에서 대표 세 명을 뽑는 경우의 수  → $NC3 = (N * (N-1) * (N - 2 ) )/ 3!$
- N명의 사람 중에서 반장 1명과 부반장 1명을 뽑는 경우의 수   → $N * ( N - 1 )$
- N명의 사람 중에서 대표 두 명을 뽑는 경우의 수  → $2 ^ N$

## 그냥 다 해보기

### 일곱 난쟁이

[https://www.acmicpc.net/problem/2309](https://www.acmicpc.net/problem/2309)

아홉 명의 난쟁이 중 일곱 명의 난쟁이를 찾는 문제

일곱 난쟁이의 키의 합은 100.

아홉 명 중에 일곱 명을 고르는 것은 아홉명 중에 두 명을 고르는 것과 같다. 

- 일단 9명의 난쟁이의 키의 합을 모두 구해 놓는다.
- 2중 포문 내에서 두 개를 뽑아 경우의 수를 만들어 놓는다.
- 전체 합에서 뽑은 두 개의 수를 뺸 결과값이 100이면 경우의 수에 포함된다.

### 사탕 게임

[https://www.acmicpc.net/problem/3085](https://www.acmicpc.net/problem/3085)

N * N 크기의 테이블에 사탕이 있다. (  N ≤ 50 )

인접한 두 칸을 고르고, 사탕을 교환한다. 

그 다음, 같은 색으로 이루어져 있는 가장 긴 연속 부분 행 또는 열을 고르는 문제 

### 날짜 계산

준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다.

준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다.

지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 

이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19)

1부터 for문을 돌리며 증가시키며 각자 맥시멈 수에 도달했을 때 1로 만들어 준다. 

E,S,M이 원하는 수 일때 답을 return  해준다.

**다른 방법으로는 나머지 연산으로 풀 수 있다.** 

모든 E,S,M에서 1을 빼면, 다음을 만족하는 가장 작은 자연수 year를 찾는 문제 이다. 

만약에 E의 경우 15까지는 계속해서 순회하게 된다. 15를 나눈 나머지가 1이면 16이다. 

- year mod15 == E
- year mod28 == S
- year mod19 == M

이런식으로 year를 0부터 증가시키면서 위의 식을 검사해 구현하는 방법도 가능하다.

### 리모컨

[https://www.acmicpc.net/problem/1107](https://www.acmicpc.net/problem/1107)

TV채널을리모컨을이용해바꾸는문제 

버튼 : 0,1,2,3,4,5,6,7,8,9,+,‒

일부 숫자 버튼이 고장났다.

현재 보고 있는 채널 : 100

이동하려고 하는 채널 : N

이때, 리모컨 버튼을 누르는 횟수를 최소로 하는 문제

예를들어, 5457에 이동하려면 5,4,5,7을 눌러 4번 만에 이동할 수 있다.

만약, 숫자 버튼 7이 고장났다면, 5, 4, 5, 6, + 또는 5 , 4, 5, 8, - 를 눌러 5번만에 이동할 수 있다. 

**즉 이 문제에서 최소한 버튼을 적게 눌러 이동하는 방법은 숫자 버튼을 누르고 + 나 - 중 하나만 연속해서 눌러야 한다.**

이동하려고 하는 채널 0 ≤ N ≤ 500000

숫자 버튼을 눌러서 이동하는 채널 c도 0 ≤ C ≤ 1000000 이면 된다. 

왜냐면 50만 번째 채널도 100에서 + 만 500100번 누르면 어디든 갈 수 있어서. 

1. 이동할 채널 C를 정한다. 
2. C에 포함되어 있는 숫자 중에 고장난 버튼이 있는지 확인한다. 
- 수를 문자열로 바꾼 다음, 한 글자씩 검사하는 방법
- 수를 10으로 계속해서 나누면서 하나씩 검사하는 방법
    - 코드
3. 고장난 버튼이 포함되어 있지 않다면 |C-N|을 계산해 +나 - 버튼을 몇 번 눌러야 하는지를 계산한다. 

```java
for(int i = 0 ; i <= 1000000; i++ ){
	int c = i;
}
```

4. 가장 처음에 보고 있는 채널은 100이기 때문에, 초기값을 100에서 숫자 버튼을 누르지 않고 이동하는 횟수로 지정해 예외처리를 해주어야 한다. 

```java
int ans = n - 100;
  if (ans < 0) {
     ans = -ans;
	}
```

이 문제 같은 경우는 예외처리를 많이 해서 어려워졌다. 

이 문제에서 기억해야 할 것은 최솟 값을 찾을 때에는 의미없는 것이 있으면 절대로 안되고, 중복되는 것이 있어서도 안된다는 것을 기억해서 문제를 풀어나가야 한다. 

### 테트로미노

전체 테트로미노의 모양의 가짓수는 19 가지이다. 

어떤 것을 고르는 경우의 수는 19가지

어디에 놓을 지를 고르는 경우의 수 **(N - 2) * ( M - 1 )**

 **시간복잡도  → O(NM)**

**19  * 500 ^ 2** = 4750000

모든 i,j 칸에 대해서 모든 값들을 만들어본다.