# 브루트 포스 (BruteForce) - 순열

순열은 보통 브루트포스로 풀게 된다 .  
임의의 수열을 서로 다른 순서로 섞을 때, 순서가 매우 중요한 의미를 가지고 있을 때    

## 순열?

임의의 수열을 다른 순서로 섞는 연산.   
뽑은 것들을 순서를 생각해서 일렬로 늘어 놓는다는 뜻    
크기가 N인 수열의 서로 다른 순열은 총 N!개가 있다.   
그냥 다 만들어보면 된다.    

## 다음 순열?

A = [1,2,3]인 경우 사전순은 다음과 같다.    
   
1,2,3   
1,3,2   
2,1,3   
2,3,1   
3,1,2   
3,2,1    

1로 시작하는 순열 이 쭉 나오고, 2로 시작하는 순열이 쭉 나오고..    
그 안쪽으로는 1, 2 , _ _... 1,3 _ _... 1, 4, _ _...// 2,1 _ _ , 2,3,_ _..    
이렇게 쭉 이뤄지고 첫 번째 순열은 오름차순이고, 맨 마지막 순열은 내림차순이다.    
결국 **어떠한 순열은 앞에 무슨 수로 이루어지는 수열  +  맨 마지막 순열이 될 수 있다.**    

그리고 그 다음 순열은 그 앞에 다음 것이 오는 첫 순열이 될 것이다.   
(예시 : 1,2, 4,3 → 1,3,2,4)    
결국 첫 순열이라는 것은 같은 것이 있으면 오름차순, 그렇지 않으면 비내림차순 그리고 마지막 순열은 내림차순을 의미하게 된다.   

***어떤 순열이 앞에 어떠한 값으로 시작하는 마지막 순열인지 구했으면, 그 다음 순열은 그 앞 부분에서 맨 마지막 부분만 달라지는 첫 순열이 된다.***

사전순으로 다음에 오는 순열과 이전에 오는 순열을 찾는 방법    
C++의 STL의 algorithm 라이브러리에는 이미 next_permutation과 prev_permutation 이 존재하기 때문에 사용하면 된다.    
자바의 경우에는 없으니까 직접 구현해야 한다. 그리고 알아놓으면 좋다.

### 방법

1. A[i - 1 ] < A[ i ] 를 만족하는 가장 큰 i 를 찾는다   
2. j ≥ i 이면서 A[j] > A[ i - 1 ] 를 만족하는 가장 큰 j 를 찾는다.    
3. A[i - 1 ] 과 A[j] 를 swap 한다.   
4. A[ i ]부터 순열을 뒤집는다.   

### 예시

*순열 : 7 2 3 6 5 4 1*

1. A[i-1] < A[i] 를 만족하는 가장 큰 i를 찾는다.( 6 )    
2. i를 포함하여 뒤에있는 수들 중 내림차순을 이루는 뒷 부분의 바로 앞의 부분의 수인 A[i-1]보다 큰 수들이 후보가 된다. ( 6,5,4 )   
3. 그 중에서 가장 뒤에 있는 ( 가장 큰 j ) 인 4와, 3을 swap 한다. (7,2,4,6,5,3,1)    
4.  A[ i ]부터 순열을 뒤집는다. ( 7, 2, 4, 1, 3, 5, 6 )   
5. 다음 순열 구하기 성공 **( 7, 2, 4, 1, 3, 5, 6 )**    

### 코드

```cpp
bool next_permutation(int *a, int n) {
  int i = n-1;
	while (i > 0 && a[i-1] >= a[i]) i -= 1; 
	//// ========= 여기까지가 1번 단계 ==========
	if (i <= 0) return false; // 마지막 순열 판단 
	int j = n-1;
	while (a[j] <= a[i-1]) j -= 1; //
	//======= 여기까지 2번 단계
		swap(a[i-1], a[j]); // ======= 3번 단계
    j = n-1;
    while (i < j) {
        swap(a[i], a[j]);
			  i += 1; j -= 1; 
		}//======== 4번 단계
    return true;
}

```

## 이전 순열


다음 순열의 응용으로 풀면 된다.(다음 순열을 구하는 방법에서 부등호를 모두 바꿈)    

## 모든 순열

java에서의 next_permutation은 이런 식으로 구하고,  do while문을 응용해서 모든 순열을 구할 수 있다. 

```java
import java.util.*;

public class Main {
    public static boolean next_permutation(int[] a) {
        int i = a.length-1;
        while (i > 0 && a[i-1] >= a[i]) {
            i -= 1;
        }

        if (i <= 0) {
            return false;
        }

        int j = a.length-1;
        while (a[j] <= a[i-1]) {
            j -= 1;
        }

        int temp = a[i-1];
        a[i-1] = a[j];
        a[j] = temp;

        j = a.length-1;
        while (i < j) {
            temp = a[i];
            a[i] = a[j];
            a[j] = temp;
            i += 1;
            j -= 1;
        }
        return true;
    }
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i=0; i<n; i++) {
            a[i] = i+1;
        }
        do {
            for (int i=0; i<n; i++) {
                System.out.print(a[i] + " ");
            }
            System.out.println();
        } while(next_permutation(a));
    }
}
```

## 외판원 순회

1-N번까지 번호가 매겨져 있는 도시가 있다.   
한 도시에서 시작해 N개의 모든 도시를 거쳐 다시 원래 도시로 돌아오려고 한다.   
(한 번 갔던 도시로는 다시 갈 수 없다.)   
이 때, 가장 적은 비용을 구하는 문제    
W[i][j] → i → 비용, 0 인 경우는 갈 수 없음.   
이 문제를 브루트포스로 풀 수 있는 이유는 문제의 조건이 "모든 도시를 거친다." , "한 번 갔던 도시로는 다시 갈 수 없다" 는 데에 있다.   
이것만으로 모든 경우를 다 살펴보아도 된다고 확신을 할 수는 없다. 문제의 조건이 작기 때문에 모든 경우를 시도해보아도 된다.