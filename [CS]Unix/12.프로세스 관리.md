# 프로세스 관리 

> 시스템이 구동되면, 리눅스는 몇 개의 기본적인 커널 프로세스를 실행시킨다.     
> 때문에 실행 중인 여러 프로그램들 사이에서 CPU나 메모리와 같은 한정된 자원이 효율적으로 사용되도록 멀티태스킹을 관리한다. 

시작시 PID가 1인 프로세스가 데몬 프로그램의 형태로 시작된다. 
사용자가 로그인을 하거나 새로운 터미널 창을 열면 서브 프로세스로  "bash 프로세스"가 할당된다. 

커널은 등록된 프로세스를 관리하기 위해 프로세스 컨트롤 블록이라는 자료구조에 각 프로세스의 정보를 저장하며 프로세스의 구별을 위해 PID를 할당한다. 

-> PCB에 포함되는 프로세스 정보 
- 프로 세스 아이디와 부모 프로세스 아이디
- 실제 소유자와 유효 소유자 그룹
- 프로세스의 현재 상태
- 프로 세스의 우선순위
- 프로세스가 사용 중인 자원에 관한 정보

## 프로세스의 생성

-> `fork()` : 부모 프로세스가 자신의 복사본 형태로 자식 프로세스를 만든다.    
-> `exec()` : 새로운 프로세스를 만드는 대신 기존 프로세스를 새로운 프로세스로 대체한다. 원래 프로세스의 메모리 공간을 새로운 프로세스의 실행 코드로 덮어쓴다.    

시스템 호출: 사용자 프로세스가 직접 할 수 없는 일을 커널에 호출

`pstree`로 프로세스트리를 확인할 수 있다. 

## 포어그라운드, 벡그라운드

셸에서 명령을 실행하면 해당 프로세스는 포어그라운드 모드로 수행된다. 

그런데 하나의 터미널에서는 포어그라운드 프로세스가 끝나기 전에는 다른 명령을 수행할 수 없음.

foreground process로 실행되는 프로세스는 키보드 입력을 받을 수 있고 화면에 출력을 할 수 있다. 즉, 터미널에 대한 제어권을 가짐

백그라운드로 실행시키려면 셸 명령의 마지막에 &을 추가하여 실행시킨다. 

백그라운드 프로세스를 포어그라운드로 전환시키는 작업 : fg jobid

job명령으로 백그라운드 프로세스의 상태 점검 

## 특수 권한

일반 사용자가 root권한이 필요할 시, (ex. /etc/passwd의 수정)       

이럴 떄 사용되는 특별한 권한을 SetUID, SetGID, StickyBit라고 한다.   

1. ls -l <파일> 실행시 소유자의 실행권한에서 s가 나타나면 해당 프로그램에 SetUID가 설정된것     
2. 그룹의 실행권한에서 s가 나타나면 SetGID    
3. 기타 사용자의 실행 권한에서 t가 나타나면 StickyBit    

ex) `-rwsr-xr-x` -> 소유자의 실행 권한에서 x 대신에 s 나타남. SetUID가 설정됨, 이경우 누가 실행시키더라도 해당 파일의 소유자가 실행시킨 것으로 간주   

해당 권한을 설정하는 방법은 

chmod -> 
세자리 8진수 앞에 4or2or1을 붙인다

## 프로세스의 상태 변화 과정
1. 사용자가 작업을 요청시 프로세스가 커널에 등록되고 생성상태가 됨
2. 생성 상태에서 하드디스크로부터 메모리로 프로세스가 로드, 프로세스가 로드되면 프로세스는 준비 상태가 됨 충분한 메모리 공간이 없다면 작업 준비 ㅏㅇ태로
3. 준비 상태에서 CPU스케줄러가 특정 프로세스에 CPU를 할당하면 해당 프로세스가 실행상태가 된다. 
